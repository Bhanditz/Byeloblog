XML = Origin mimic with(
  doctype: fn("Print a doctype string", type,
    case(type,
      "xml",   #[<?xml version="1.0" encoding="utf-8"?>\n],
      "xhtml", "<!DOCTYPE html>\n")),
  comment: fn("Print a comment", text, "\n<!--\n#{text}\n-->\n"),
  attr:    fn("Print an attribute inline", k, v,
             " #{k}=\"#{v}\""),
  dotify:  fn("Convert exclamation marks to dots in tag names.", tagname,
             tagname replaceAll(/!/, ".")),
  render:  fn(initial_quoted,
             let(
                 stack,    Array(),
                 pair?, fn(unreal_arg,
                   let(arg, unreal_arg asArray [0],
                     if(arg hasCell("name"),
                       false,
                       if(arg hasCell("args"),
                         if(arg args length ==(3),
                           arg args [1] name ==("⇒")))))),
                 keyword?, fn(unreal_arg,
                   ؟say("Unreal arg: #{print_with_forms(unreal_arg)}")
                   let(arg, unreal_arg asArray [0],
                     ؟say("Real-real arg: #{print_with_forms(arg)}")
                     if(arg hasCell("name"),
                       false,
                       if(arg hasCell("args"),
                         ؟say("Name: #{arg args [0] name}")
                         ؟say("Matches: #{(arg args [0] name ~= /^.*:$/) asBool asText}")
                         (arg args [0] name ~= /^.*:$/) asBool,
                         false)))),
                 render:tag, fn(unreal_tag,
                   tag = unreal_tag asArray [0]
                   ؟say(tag)
                   ؟say(tag name)
                   ؟say(print(tag args))
                   let(
                     ret, "<#{XML dotify(tag name)}#{tag args map(arg,
                          cond(
                            pair?(''(`(arg))),     " #{arg args [0]}=\"#{arg args [2]}\"",
                            keyword?(''(`(arg))),  " #{arg args [0] name [0 … -2]}=\"#{arg args [1]}\"",
                                                   "")
                          ) join}>",
                     stack push!("</#{tag name}>")
                     ret)
                 ),
                 render:main, fn(quoted,
                   let(
                   temp, quoted asArray map(msg_chain,
                     ؟say("render:main: #{print_with_forms(msg_chain)}")
                     if(eval(unquote(''(Mirror ["pre_scala_mirror"] message?(`(''(`(msg_chain))))))) or(
                        eval(unquote(''(Mirror ["pre_scala_mirror"] call?(`(''(`(msg_chain)))))))),
                       Array(msg_chain),
                       msg_chain args) map(msg,
                         ؟say(print_with_forms(msg))
                         ؟say("Msg name: #[#{msg name}]")
                         ؟say(print(msg))
                         ؟say(print(msg args))
                         cond(                     
                           eval(unquote(''(Mirror ["pre_scala_mirror"] dot?(`(''(`(msg))))))),
                             if(stack length > 1, stack pop!, ""),
                           eval(unquote(''(Mirror ["pre_scala_mirror"] idempotent?(`(''(`(msg))))))),
                             msg asText,
                           case(msg name,
                             "",   #. say("Commated: #{print_with_forms(msg args)}") . msg args map(x, XML render(''(`(x)))) join,
                             "!",  stack push!(" -->"). "<!-- ",
                                   render:tag(''(`(msg)))))) join) join,
                   temp +(stack join))),
                 render:main(initial_quoted)
           )),
  fromQuotedFile: fn("Read a file in XML render compatible form, and turn it into a Message.", filename, context: XML,
    #; Access 'context' through lexical cell "context"
    eval(read(FileSystem readFully(filename))))
)
